# 2진수 덧셈

&nbsp; 두 비트를 서로 더한 결과는 두 비트를 XOR한 값과 같고, 올림은 두 비트를 AND 한 값과 같다.

#### 오버플로 *overflow*

&nbsp; 덧셈 결과가 우리가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어나면서 생기는 현상  
즉, MSB에서 올림이 발생했다는 뜻이다.  
<br>
&nbsp; 컴퓨터에는 조건코드 (또는 상태코드) 레지스터 *condition code register* 라는 것이 있어서 몇가지 정보들을 담아두게 된다.
이런 정보들 중에 오버플로 비트 *overflow bit* 가 있고, MSB에서 발생한 올림값이 여기에 저장되게 된다.
반대로 음수를 표현하는 것에서 MSB 위쪽에서 1을 빌려와야 하는 경우를 일컬어 언더플로 *underflow*라고 한다.

## 음수표현
### 부호와 크기 표현법
&nbsp; 비트에서 부호를 표기할 때 MSB를 부호로 사용하기로 결정했다.  
4비트 중 3비트를 사용하고 남는 하나의 비트로 부호를 정한다.

> 부호를 뜻하는 자리가 1이면 음수, 0이면 양수를 뜻한다.

부호를 제외한 나머지 비트를 수의 크기, 즉 0부터의 거리(절댓값)으로 표현한다. 

#### 부호 표기법에 대한 단점
1. 비트를 구성하는데 드는 비용에서 0을 표현하는 방법이 두가지라 비용이 낭비된다.   
두 0 표기법 중 하나를 다른 숫자를 표기하는데 사용하는 편이 낫다
2. 부호와 크기 표현법을 사용하면 XOR과 AND를 통한 덧셈 계산을 사용할 수 없다.

### 1의 보수 표현법
&nbsp; 양수의 모든 비트를 뒤집어서 표현한다.  
또는 같은 표현으로 NOT 연산을 통해 보수를 얻는다.

#### 단점
1. 0을 여전히 두가지 방식으로 표현하는 문제가 있다.
2. 덧셈을 쉽게 할 수 없다.  
이를 해결 하려면 MSB에서 올림이 발생한 경우 LSB로 올림을 전달해야한다.  
이를 순환올림 *end-around carry* 이라고 한다.

1의 보수를 사용한 +2와 -1 더하기
```angular2html
  0010 | +2
+ 1110 | -1
---------
  0000 | 0
+ 0001 | 1 -> 순환올림
---------
  0001 | +1
```

> 현재 컴퓨터에서는 부호와 크기 표현법과 1의 보수 표현법을 둘다 사용하지 않는다. 그에 대한 이유는
> 추가적인 하드웨어 없이 제대로 작동할 수 없고, 하드웨어를 추가해야하는 것은 곧 비용이 든다는 문제가 있다.

### 2의 보수 표현법
&nbsp; 얻으려는 음수의 절대값에 +1을 더했을 때 0이 나오는 값을 음수로 표현한다.  
즉, 어떤 수의 비트를 뒤집고 (NOT 연산을 취하고) 1을 추가하면 음수를 얻을 수 있다.  
MSB에서 올림이 발생하는 값은 버림한다.

> 현재까지 부호가 있는 정수를 표현할 때 가장 널리 쓰이는 방법이다.  
> 같은 숫자로 이뤄진 수를 보더라도 문맥에 따라 표현하는 값이 달라질 수 있다는 점을 염두에 두어야 한다.
> 2진수 1111은 2의 보수에서 -1, 부호와 크기 표현법에서 -7, 1의 보수에서는 -0이 된다.
