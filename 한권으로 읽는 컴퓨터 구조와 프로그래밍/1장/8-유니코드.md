# 유니코드
## 비트 표현에 대한 다른 표준의 진화
&nbsp; 아스키는 영어를 표현하는 모든 문자를 표현하고 있어 상당 기간 표준 역할을 했지만 초기 컴퓨터는 대부분 영어권 국가의 것이었다.
이후 널리 쓰이게 되면서 국제 표준화 기구 *ISO, International Standards Organization*는 *ISO-646*과 *ISO-8859*를 도입했다.
이 표준들은 아스키를 기본으로 유럽 언어에 필요한 엑센트 기호나 그 외 발음 기호를 추가한 것이다.  
&nbsp; 일본어 (*JISX 0201*), 중국어, 아랍어, 한국어 (*KS C 5601*) 등의 표준도 생겨났다.  

## 유니코드
각기 다른 표준의 이유는 비트가 지금보다 더 비싼 시절에 표준이 만들어 졌기 때문에 문자를 7비트, 8비트에 욱여넣었고, 비트 가격이 떨어짐에 따라
유니코드 *Unicode*라는 새로운 표준을 만들어 문자에 16비트 코드를 부여했다(현재는 21비트까지 확장되었다).  
즉, 유니코드는 모든 문자와 대비되는 문자표를 가진 국제 표준이다.  

## 유니코드 변환 형식 8비트 *UTF-8*
&nbsp; 유니코드를 인코딩 *encoding*하는 방식이다.  
인코딩은 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴을 의미한다.  

> 비트를 통해 숫자를 표현하고,  
> 숫자를 통해 문자를 표현하고,  
> 다시 다른 숫자를 통해 문자를 표현하는 숫자를 표현한다. :: UTF-8

### *UTF-8, Unicode Transformation Format-8 bit*
&nbsp; 미국의 컴퓨터과학자 켄 톰슨*Ken Thompson*과 캐나다 프로그래머 *Rob Pike*가 만든 것으로,
인코딩 방법이 하위 호환성과 효율성 때문에 가장 널리 쓰이는 방법이다.

#### UTF-8
- 모든 아스키 문자를 8비트로 표현한다.  
아스키 데이터를 인코딩할 때는 추가 공간이 필요치 않다.
- 아스키가 아닌 문자의 경우 아스키를 처리하는 프로그램이 깨지지 않는 방법으로 문자를 인코딩한다.

#### UTF-8의 특징
- 문자를 *옥텟 octet*이라 부르는 8비트 덩어리의 시퀀스로 인코딩한다.
- 첫번째 덩어리 (*8비트*)의 MSB 쪽에 있는 비트들이 8비트 덩어리 *옥텟* 시퀀스의 길이를 표현한다.  
  MSB 쪽의 비트 패턴이 겹치지 않기 때문에 덩어리의 맨 앞을 식별하기 쉽다.
- 가변 바이트 길이를 선언한다.  
  영어는 1byte, 한글은 3byte를 사용한다.
 
#### UTF-8의 규칙
1. 1개의 바이트를 사용한다.   
*MSB (가장 큰 비트)*에 0을 할당하고, 나머지 7비트에 기존의 아스키 코드를 모두 할당한다.  

UTF-8의 A 표현
> [0] 1 0 0 0 0 0 1

2. 사용하려는 바이트가 2개 이상일 경우 **첫 바이트의 앞 MSB 비트**를 시퀀스의 길이로 표현한다.  
2개인 경우 MSB 3비트 - 110으로 시작  
3개인 경우 MSB 4비트 - 1110으로 시작  
4개인 경우 MSB 5비트 - 11110으로 시작  
나머지 바이트에는 여러 바이트에서 연결되었음을 알리는 비트 *10*를 먼저 넣는다.

UTF-8 &pi;
> 파이는 11비트, 2byte로 표현이 가능하다.  
> 첫번째 바이트 - [1][1][0] 0 1 1 1 1  
> 두번째 바이트 - [1][0] 0 0 0 0 0 0

UTF-8 &clubs;
> 클로버는 16비트에 들어가므로 3byte로 표현한다.  
> 첫번째 바이트 - [1][1][1][0] 0 0 1 0  
> 두번째 바이트 - [1][0] 0 1 1 0 0 1  
> 세번째 바이트 - [1][0] 1 0 0 0 1 1  

#### 장점
- 프로그램이 문자 경계를 찾아야 하는 경우 해당 특성이 매우 용이하다.  
- 모든 아스키 문자는 7비트에 들어가므로 덩어리 하나만 사용해서 표현이 가능하다.
- 영어의 경우 비 아스키 기호를 사용하는 언어보다 더 적은 용량으로 문자 인코딩이 가능하므로 영어 사용자에 편리하다.

