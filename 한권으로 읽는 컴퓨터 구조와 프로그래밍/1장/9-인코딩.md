# 인코딩
&nbsp; 문자를 표현하는 비트들을 표현하는 숫자들을 표현하기 위해 숫자를 사용하는 UTF-8도 있지만
문자를 사용해 수를 표현하는 방법도 있다.  
컴퓨터 간 통신이 시작되고 더 많은 정보를 송수신 하기 위해 2진 데이터를 보내기 위한 많은 노력이 있었다.
하지만 아스키 코드 중 상당수가 제어 문자로 예약되어 있었기 때문에 이런 제어 문자를 시스템에 따라 처리하는 방식이 달라
어려움을 겪었고 7비트만 송수신 가능한 몇몇 시스템에 의해 제약을 받게 되었다.

## 출력 가능하게 변경한 인코딩
&nbsp; 출력 가능하게 변경한 인코딩 *QP encoding, Quoted-Printable encoding*은 8비트 데이터를
7비트 데이터만 지원하는 통신 경로를 통해 송수신 하기위한 인코딩 방법이다.  
전자 우편 첨부를 처리하기 위해 만들어진 인코딩 방법이기도 하다.  

#### QP 인코딩의 규칙
- = 다음에 바이트의 각 니블 (*4bit*)을 표현하는 16진 숫자 2개를 추가해 8비트 값을 표현한다.  
여기서는 = 기호가 특별한 의미이므로 =를 표현하기 위해 =3D를 사용한다.
- 줄의 맨 끝에 탭 *tab*과 공백 *space*문자가 온다면, 이를 각각 =09와 =20으로 표현해야만 한다.
- 인코딩된 데이터는 한 줄이 76자를 넘을 수 없다.
- 줄의 맨 뒤가 =로 끝나면 가짜 줄바꿈 *soft line break*을 뜻하며 수신 쪽에서는 QP로 인코딩된 데이터를
디코딩 할 때 이 뒤에 =를 제거하고 해석한다.

#### 단점
- 1byte를 표현하기 위해 3byte를 사용해야 한다.

## Base64 인코딩
&nbsp; QP인코딩보다 효율적이고, 3byte 데이터를 4문자로 표현한다.  
3byte의 24bit를 네가지 6bit 덩어리로 나누고, 각 덩어리의 6비트값에 출력 가능한 문자를 할당해서 표현한다.
전자우편 첨부파일 전송에 많이 사용중인 인코딩 방식이다.

#### Base64의 규칙 예제
0, 1, 2라는 세 바이트를 인코딩하면 AAEC이다.
> (0) 00000000 | (1) 00000001 | (2) 00000010  
> ---> 0(A) 000000 | 0(A) 000000 | 4(E) 000100 | 2(C) 000010

- 이 인코딩은 모든 3byte 조합을 4byte 조합으로 변환할 수 있다.
- 원본 데이터 길이가 3byte의 배수라는 보장은 없다.
- 패딩 *padding*문자를 도입해 이런 문제를 해결한다.
- 원본 데이터가 2byte 남으면 끝에 =를 붙이고, 1byte가 남으면 끝에 ==를 붙인다.

## URL 인코딩
&nbsp; 웹페이지 URL에 있는 %26이나 %2F 같은 시퀀스들은 URL에서 특별한 의미를 지니는 문자를
리터럴 *literal*로 사용할 필요가 있기 때문이다.

URL 인코딩은 퍼센트 인코딩 *percent-encoding*이라고도 부르는데, %뒤에 어떤 문자의
16진 표현을 덧붙이는 방식으로 인코딩한다.  
> 슬래시 문자 / 의 아스키 코드는 47, 16진수로 2F이다.  
> 슬래시를 리터럴로 사용하고 싶을 경우
> %2F라는 문자열로 대신한다.  
> % 문자를 리터럴로 사용할 경우 %25로 사용한다.




